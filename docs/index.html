<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>環保辨識器</title>
  <meta name="description" content="請拍照或上傳圖片，後端以 OpenAI 分析回傳分類結果（前端不含任何金鑰）。" />
  <style>
    /* 略：保留你原本的樣式即可 */
    /* ... 這裡省略（你的 CSS 原封不動保留） ... */
  </style>
</head>
<body>
  <div class="leaves" id="leaves"></div>

  <div class="container" style="position:relative; z-index:1">
    <h1 class="center">環保辨識器</h1>
    <div class="subtitle">請拍照或上傳你的圖片（由後端分析）</div>

    <div class="card stack center">
      <div id="drop" class="drop" aria-label="上傳區">
        <!-- ✅ 兩個 input：相簿(無 capture) + 相機(有 capture) -->
        <input id="fileGallery" type="file" accept="image/*" style="display:none" />
        <input id="fileCamera"  type="file" accept="image/*" capture="environment" style="display:none" />

        <svg class="arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 19V6"/><path d="m5 13 7-7 7 7"/></svg>
        <img id="preview" class="preview" alt="預覽" />
      </div>

      <div class="row">
        <!-- ✅ 分成兩顆按鈕 -->
        <button id="btnGallery" class="btn ghost" type="button">相簿</button>
        <button id="btnCamera"  class="btn ghost" type="button">拍照</button>
        <button id="clear" class="btn warn" type="button">刪除</button>
        <button id="run" class="btn" disabled>辨識</button>
      </div>

      <div class="progress"><div id="bar" class="bar"></div></div>
      <div id="status" class="small">等待上傳圖片…</div>
    </div>

    <div class="card" style="margin-top:16px">
      <div id="resultLine" class="center" style="font-size:18px">輸出：<span class="small">尚未辨識</span></div>
    </div>
  </div>

<script>
  // ====== 後端 API ======
  const API_URL = "https://waste-backend-61ec.onrender.com/api/classify"; // ← 換成你的

  // ====== 背景落葉（保留你原本的） ======
  const leaves = document.getElementById('leaves');
  for(let i=0;i<16;i++){
    const el = document.createElement('div'); el.className='leaf';
    const left = Math.random()*100; const delay = Math.random()*12; const dur = 16 + Math.random()*12; const size = 12+Math.random()*14;
    el.style.left = left+'%'; el.style.bottom='-40px'; el.style.width=size+'px'; el.style.height=size+'px';
    el.style.animation = `floatY ${dur}s linear ${delay}s infinite`;
    leaves.appendChild(el);
  }

  // ====== Utils ======
  const els = {
    fileGallery: document.getElementById('fileGallery'),
    fileCamera:  document.getElementById('fileCamera'),
    btnGallery:  document.getElementById('btnGallery'),
    btnCamera:   document.getElementById('btnCamera'),
    clear:       document.getElementById('clear'),
    drop:        document.getElementById('drop'),
    preview:     document.getElementById('preview'),
    run:         document.getElementById('run'),
    status:      document.getElementById('status'),
    bar:         document.getElementById('bar'),
    resultLine:  document.getElementById('resultLine'),
  };

  function setProgress(p){ els.bar.style.width = `${Math.max(0, Math.min(100, p))}%`; }
  function showPreview(url){ els.preview.src = url; els.preview.style.display = 'block'; }
  function clearPreview(){
    els.preview.src = ''; els.preview.style.display = 'none';
    els.run.disabled = true;
    els.resultLine.innerHTML = '輸出：<span class="small">尚未辨識</span>';
  }
  function ripple(e){
    const x=e.offsetX, y=e.offsetY; const s=document.createElement('span');
    s.className='ripple'; s.style.left=x+'px'; s.style.top=y+'px';
    e.currentTarget.appendChild(s); setTimeout(()=>s.remove(), 800);
  }

  // 🔧 讀檔並壓縮成 DataURL（避免原圖太大）
  function compressImage(file, maxSide = 1280, quality = 0.85) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
        const w = Math.round(img.width * scale);
        const h = Math.round(img.height * scale);
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
        canvas.toBlob(blob => {
          if (!blob) return reject(new Error('toBlob failed'));
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result); // DataURL
          fr.readAsDataURL(blob);
        }, 'image/jpeg', quality);
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  let currentDataURL = null;

  async function setPreviewFromFile(file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    showPreview(url);
    // 壓縮存成 DataURL，等等直接送出去
    currentDataURL = await compressImage(file, 1280, 0.85);
    els.run.disabled = false;
    els.status.textContent='圖片就緒，按「辨識」';
  }

  // ====== 按鈕/輸入事件 ======
  els.btnGallery.addEventListener('click', (e)=>{ ripple(e); els.fileGallery.click(); });
  els.btnCamera.addEventListener('click',  (e)=>{ ripple(e); els.fileCamera.click();  });
  els.clear.addEventListener('click',     (e)=>{ ripple(e); currentDataURL=null; clearPreview(); els.status.textContent='已清除圖片'; });

  els.fileGallery.addEventListener('change', (e)=> setPreviewFromFile(e.target.files[0]));
  els.fileCamera .addEventListener('change', (e)=> setPreviewFromFile(e.target.files[0]));

  // Drag & Drop 照舊
  ['dragenter','dragover'].forEach(evt=> els.drop.addEventListener(evt, (e)=>{ e.preventDefault(); els.drop.classList.add('drag'); }));
  ['dragleave','drop'].forEach(evt=> els.drop.addEventListener(evt, (e)=>{ e.preventDefault(); els.drop.classList.remove('drag'); }));
  els.drop.addEventListener('drop', (e)=>{ const f=e.dataTransfer.files?.[0]; if(f) setPreviewFromFile(f); });

  // 顯示結果：≥75% 不顯示機率
  function setResult(name, score){
    const p = Math.round((score||0)*100);
    if (score >= 0.75) {
      els.resultLine.innerHTML = `輸出：就是（<b>${name||'未知'}</b>）`;
    } else if (score >= 0.45) {
      els.resultLine.innerHTML = `輸出：較可能（${p}%）是（<b>${name||'未知'}</b>）`;
    } else {
      els.resultLine.innerHTML = `輸出：<span class="small">不確定（最高 ${p}%）</span>`;
    }
  }
  function setUncertain(msg){ els.resultLine.innerHTML = `輸出：<span class="small">${msg}</span>`; }

  // ====== 呼叫後端 ======
  els.run.addEventListener('click', async (e)=>{
    ripple(e);
    try{
      if(!currentDataURL) return setUncertain('尚未選擇圖片');
      setProgress(15); els.status.textContent='上傳中…';

      const resp = await fetch(API_URL, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ image: currentDataURL })
      });
      if(!resp.ok){ const t = await resp.text(); throw new Error('後端錯誤：'+resp.status+' '+t); }

      els.status.textContent='分析中…'; setProgress(60);
      const data = await resp.json();
      const top = data.top || data; // {top:{name,score}} 或直接 {name,score}
      setResult(top.name, top.score);

      els.status.textContent='完成'; setTimeout(()=> setProgress(0), 900);
    }catch(err){
      console.error(err);
      setUncertain(err.message||'推論發生錯誤'); els.status.textContent='失敗'; setProgress(0);
    }
  });
</script>
</body>
</html>
